---
title: "Worflow"
author: "Workflow team"
date: "06/06/2017"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",message=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
#bioconductor:
library(scRNAseq)
library(scone)
library(clusterExperiment)
#github
library(zinbwave)
library(slingshot)
#CRAN
library(ggplot2)
library(gplots)
library(magrittr)
library(matrixStats)
library(Rtsne)
library(RColorBrewer)
library(digest)
library(rARPACK)
set.seed(20)
if(packageVersion("clusterExperiment")<'1.3.0.9009') stop("must have current develop version to avoid bugs")
```


```{r}
runZinb <- T
runClus <- T
NCORES <- 7
```

EAP: if we are going to ultimately use these functions, it would be good to add them to the package for zinbwave.

FP: yes, I agree.

```{r residuals}
compute.zinb.loglik <- function(Y, zinb){
  mu = t(getMu(zinb)) 
  theta = getTheta(zinb)
  theta_mat = matrix(rep(theta, ncol(Y), ncol = ncol(Y)))
  pi = t(getPi(zinb))
  log( pi * (Y == 0) + (1 - pi) * dnbinom(Y, size = theta, mu = mu) )
}

compute.deviance.residuals <- function(Y, zinb){
  mu_hat = t(getMu(zinb)) 
  pi_hat = t(getPi(zinb)) 
  Y_hat = (1 - pi_hat) * mu_hat
  ll = compute.zinb.loglik(Y, zinb)
  sign = 1*(Y - Y_hat > 0)
  sign[sign == 0] = -1
  sign * sqrt(-2 * ll)
}
```


# TL;DR

This document is a temptative of workflow with the following steps  

- Dimensionality reduction using zinbwave to get W which should capture the biology,
- Cluster cells using clusterExperiment on W to get the cluster labels,   
- Get lineage using slingshot on W and cluster labels from clusterExperiment,  
- Get DE genes between lineages/clusters.  

Along the worflow, use deviance residuals as adjusted values.

EAP: small request. Can everyone put a line between the beginning of a r chunk and text? It makes it nicely formated for my text editor. 

# Steps of the workflow
## Create a SummarizedExperiment object

Along the workflow, we want to use a unique SummarizedExperiement object carrying all the data we need.

EAP: I have updated the code to pull from a dataset on the repos that is created with the `createData.R` file. For now, I am filtering to the top 1000 most variable genes there, though we might want to add that to the code for the article. This will be slightly different data from Russell's, which didn't use all of the samples. We can adjust that decision later, or just compare the samples that are the same. (Russell's clusterLabels are in the meta data)

EAP: zinbFit doesn't accept data.frame objects, so currently have to have a `data.matrix` command. Should it be changed so that it does?

```{r datain}
#counts<-read.table("../data/oeCufflinkCountData.txt",sep="\t",header=TRUE)
core <- read.table("../data/oeCufflinkCountData_1000Var.txt",
                   sep = "\t", header = TRUE)
core <- data.matrix(core)
metadata <- read.table("../data/oeMetadata.txt", sep = "\t", header = TRUE)
# symbol for samples missing from original clustering
metadata$clusterLabels[is.na(metadata$clusterLabels)] <- -2
```

Here we only look at the 1000 most variable genes. EAP: see note above, I've commented out the filtering and added it to the `createData.R` for now. 

```{r batches}
batch <- metadata$Batch
```

Cells have been processed in `r length(unique(batch))` different batches

```{r}
col_batch = rep(brewer.pal(9, "Set1"), 2)
names(col_batch) = unique(batch)
table(batch)
```

We have qc measures from the data

```{r qc}
qc <- metadata[, !names(metadata) %in% c("Batch", "Experiment", "clusterLabels")]
head(qc, 2)
```

```{r clusterlabels}
clus.labels <- metadata[, "clusterLabels"]
```

In published work (FP: add ref), cells have been clustered into `r length(unique(clus.labels))` different clusters

```{r}
col_clus <- c("transparent", brewer.pal(12, "Set3"), brewer.pal(8, "Set2"))
col_clus <- col_clus[1:length(unique(clus.labels))]
names(col_clus) <- sort(unique(clus.labels))
table(clus.labels)
```

Batches are kind of confounded with the biology

```{r}
table(data.frame(batch = as.vector(batch),
                 cluster = clus.labels))
```

We have `r ncol(core)` cells.

```{r lookatdata}
dim(core)
core[1:3, 1:3]
```

Let's create a SummarizedExperiment object to store the raw counts and information about the data, that is batches, published labels, and quality control measures.

```{r}
se <- SummarizedExperiment(assays = list(rawCounts = core),
                           colData = metadata)
```


## Dimensionality reduction adjusting for gene and cell level covariates

To cluster and get lineages we want to reduce the dimension of the data. We are going to use zinbwave to do so. First, let's fit zinbwave with first K = 0 to compute normalized values (i.e. deviance residuals) adjusted for batches. We could also adjust for gene length or GC content here. We then fit zinbwave to get the dimensionality reduced matrix W specifying the number of dimension K = 50. Eventually, we will call zinbwave just once where we would have an argument in zinbFit like "compute_normalized_values" in c(TRUE, FALSE). For K = 0 and K = 50, we correct for batch effect including batches in X.

```{r}
fn0 <- '../data/zinb_k0_batch.rda'
if (runZinb & !file.exists(fn0)){
  mod <- model.matrix( ~ batch)
  print(system.time(zinb0 <- zinbFit(core, ncores = NCORES,
                                     K = 0, X = mod)))
  save(zinb0, file = fn0)
}else{
  load(fn0)
}

fn50 <- '../data/zinb_k50_batch.rda'
if (runZinb & !file.exists(fn50)){
  mod <- model.matrix( ~ batch)
  print(system.time(zinb50 <- zinbFit(core, ncores = NCORES,
                                      K = 50, X = mod)))
  save(zinb50, file = fn50)
}else{
  load(fn50)
}
```

### Normalized values

We use deviance residuals as normalized values for visualization. FP: explain rational: K=0 so residuals capture the bio adjusting for batch. Let's check that deviance residuals look ok.

```{r}
res <- compute.deviance.residuals(core, zinb0)
res[1:3,1:3]
```

Boxplot of the normalized values for each cell. It seems that correction for batches is ok.

```{r}
res_order <- res[, order(as.numeric(batch))]
col_order <- as.numeric(batch)[order(as.numeric(batch))]
boxplot(res_order, main='Boxplot of normalized values\ncolor=batch',
        col = col_order, staplewex = 0, outline = 0, border = col_order, xaxt = 'n')
```

PCA on the normalized values where color are for batches on the left and previously found clusters on the right. We want no clustering on the left side and clustering on the right side.

```{r}
pca <- prcomp(t(res))
par(mfrow = c(1,2))
plot(pca$x, col = col_batch[batch], pch = 20,
     main="PCA of normalized values\ncolor=batch")
plot(pca$x, col = col_clus[as.character(clus.labels)], pch = 20,
     main = "PCA of normalized values\ncolor=cluster")
par(mfrow = c(1,1))
```

Let's add the normalized values as an assay dataset in our SummarizedExperiment object.

```{r}
assays(se)[['normalizedValues']] <- res
```

### W

Let's check that performing MDS on W we have something coherent with published clusters.

```{r}
W <- getW(zinb50)
d <- dist(W)
fit <- cmdscale(d, eig = TRUE, k = 2)
plot(fit$points, col = col_clus[as.character(clus.labels)], main = 'MDS', pch = 20,
     xlab = 'Component 1', ylab = 'Component 2')
legend(x = 'bottomright', legend = unique(names(col_clus)), cex = .5,
       fill = unique(col_clus), title = 'Sample')
```

Let's add W to the colData of our SummarizedExperiment object.

```{r}
W <- data.frame(W)
colnames(W) <- paste0('W', 1:ncol(W))
colData(se) <- cbind(colData(se), W)
```


FP: what do you think of implemented a "compute_normalized_values" argument to zinbFit for summarizedExperiment objects where zinbFit would take as input a SummarizedExperiment object and return a summarizedExperiment object with slots added for normalized values and W?

## Cluster of cells

We use clusterExperiment with W.

FP: What about the following call to RSEC?

EP: I updated it to work on a SE object so that it has the meta data. If you have a summarized experiment object with W already, you could use that as long as assay(seObj) gives W. 


```{r rsec_50}
W <- colData(se)[, grepl('^W', colnames(colData(se)))]
W <- as.matrix(W)
fn <- '../data/RSEC_W.rda'
if (runClus & !file.exists(fn)){
	metadata$clusterLabels[is.na(metadata$clusterLabels)]<- -2 #symbol for samples missing from original clustering
  seObj<-SummarizedExperiment(t(W),colData=metadata)
 print(system.time(  ceObj <- RSEC(seObj, k0s = 4:15, alphas = c(0.1), betas = 0.8,
                clusterFunction = "hierarchical01", minSizes=1,
                ncores = NCORES, isCount=FALSE,
                subsampleArgs = list(resamp.num=100,
                                     clusterFunction="kmeans",
                                     clusterArgs=list(nstart=10)),
                seqArgs = list(k.min=3, top.can=5), verbose=TRUE,
                combineProportion = 0.7,
                mergeMethod = "none")
				))
  save(ceObj, file = fn)
}else{
  load(fn)
}
```


```{r examineCombineMany}
plotClusters(ceObj, colPalette = c(bigPalette, rainbow(200)))
```

```{r plotcoclust}
plotCoClustering(ceObj)
```

```{r}
table(primaryClusterNamed(ceObj))
sum(primaryCluster(ceObj) == -1)
```

FP: Elizabeth, we are working with the W here, does the locfdr make sense in this context? I set eval=FALSE in the next chunk to skip the merging step, let me know if you would rather keep using it. And if we want to still use the merging step, would we want to include it in RSEC function arguments instead of separately?

EP: I don't think the merging step on the W makes a whole lot of sense -- the method is irrelevant. The merging is based on calculating the % of genes found significant (the specific method is arbitrary). The best thing would be to replace the W with residuals in the assay of `ceObj` (or whatever data that you will do the DE on for the time stuff below), and then run the merging step on that data.  I'm not particularly fond of `locfdr`. It was probably the method that gave the best merging to Russell and Diya. You'd really have to run `mergeClusters` setting `plotInfo="all"` and look at the results and decide both the cutoff level and the method. 

EP: Also, if you don't save the output of `mergeClusters` it doesn't update `ceObj`. I was calling it for just the resulting plots, since it was already merged in RSEC above. I've changed to code to update ceObj below. 

```{r examineMergeClusters,eval=FALSE}
#re-does merging simpling to make plot 
#something like:
#assay(ceObj)<- ...
# if that replacement data should be considered on the transformed scale in plots, etc, the transformation function should be fixed as well:
#transformation(ceObj)<- ...
ceObj<-mergeClusters(ceObj, mergeMethod = "locfdr",
              plotInfo = "mergeMethod", cutoff = 0.01)
```

```{r heatmap }
plotHeatmap(ceObj, clusterSamplesData = "dendrogramValue", 
            breaks = .99)
```

```{r compareClusters}
plot(fit$points, col = col_clus[as.character(clus.labels)],
     main = 'MDS W, color = published clusters', pch = 20,
     xlab = 'Component1', ylab = 'Component2')
legend(x = 'bottomright', legend = unique(names(col_clus)), cex = .5,
       fill = unique(col_clus), title = 'Sample')
```

```{r}
palDF <- ceObj@clusterLegend[[1]]
pal <- palDF[, 'color']
names(pal) <- palDF[, 'name']
plot(fit$points, col = pal[primaryClusterNamed(ceObj)],
     main = 'MDS W, color = our new clusters', pch = 20,
     xlab = 'Component1', ylab = 'Component2')
legend(x = 'bottomright', legend = names(pal), cex = .5,
       fill = pal, title = 'Sample')
```



So, let's look at a heatmap on normalized values.

FP: Elizabeth, I did not find how to define the column annotation track in the plot below to have the same colors as in ceObj@clusterLegend[[1]]. I tried to use arguments annColors and annCol from aheatmap as it is said in plotHeatmap documentation that for signature matrix arguments can be passed to aheatmap. But I got the error "The following arguments to aheatmap cannot be set by the user in plotHeatmap:Rowv,Colv,color,annCol,annColors".

EP: Fanny, you would need to use the argument 'clusterLegend'. That argument takes either the format of aheatmap (list with each element a *named* vector of colors) or the format of the clusterExperiment object (i.e. list with each element a matrix with columns for `name` and `color`). So I think the following code will run, though it might need the list to have names...

But an easier fix to the code would be to set `visualizeData` option. I haven't tested this because I don't have the objects need run, so let me know if there is error.

```{r}
# sampleData <- data.frame(ours = primaryCluster(ceObj))
# plotHeatmap(assays(se)$normalizedValues,
#             main = 'Normalized values, 1000 most variable genes',
#             clusterSamplesData = ceObj@dendro_samples,
#             sampleData = as.matrix(sampleData),clusterLegend=ceObj@clusterLegend[1])
# easier fix:
plotHeatmap(ceObj, visualizeData=assays(se)$normalizedValues,
whichClusters="primary",
            main = 'Normalized values, 1000 most variable genes')

```


## Get lineages

```{r}
table(data.frame(published = clus.labels,
                 ours = primaryClusterNamed(ceObj)))
```

Cluster name | Description | Correspondence
-------------|-------------|-----------------
m1 | resting HBC | original 1, 5
m2 | activated HBC | original 5
m3 | GBC / immature neurons / MV 1 | original 2, 3, 11
m4 | Sus | original 4, 7
m5 | new | new
m6 | new | new
m7 | Neuron | original 9, 12
m8 | Immature Neuron | original 10, 14
m9 | Microvillus | original 15
m10 | Immature Neuron | original 14



The goal of this section is to see if we need to refit zinbwave when we want to run slingshot. We run slingshot in the supervised and unsupervised mode and we try k=3, k=4 in W.

FP: We need to work on the cluster coloring (!) and the matching with the clusters you found for the paper with Russell, maybe by changing the parameters in clusterMany?

EP: The function plotClusters aligns the clusters and can return the aligned coloring between clusterings. There is an option to return an updated CE object that changes the colors in clusterLegend to match the new colors found by aligning the clusters (`resetNames` and `resetColors` arguments). These haven't been extensively tested in real life because I don't think we've used them much. But it would be good to demonstrate!

```{r}
Kvec <- c(3, 4)
```

### Use previous W, no re-fitting 
#### Unsupervised

```{r slingshot_unsup}
our_cl <- as.factor(primaryClusterNamed(ceObj))
cl = our_cl[our_cl != "-1"]
for (k in Kvec){
  X <- W[our_cl != "-1", 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1")
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```

#### Supervised


```{r slingshot_sup}
# m11 - original 15 - Microvillus
# m7, m8 - original 9, 12 - Neuron
# m4 - original 4, 7 - Sus


for (k in Kvec){
  X <- W[our_cl != "-1", 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1",
                           end.clus = c("m11", "m7", "m8", "m4"))
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```


### Re-fitting zinbwave
#### Unsupervised

```{r refit_zinb}
mod <- model.matrix(~ batch[our_cl != "-1"])
fn <- '../data/refit_zinbwave_slingshot.rda'
if (runZinb & !file.exists(fn)){
  zinbList <- lapply(Kvec, function(k){
    zinbFit(core[, our_cl != "-1"], X = mod, K = k, ncores = NCORES)
  })
  save(zinbList, file = fn)
}else{
  load(fn)
}
```

```{r slingshot_unsup_refit}
for(k in Kvec) {
  X <- getW(zinbList[[k - 1]])[, 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1")
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```

#### Supervised

```{r slingshot_sup_refit}
for(k in Kvec){
  X <- getW(zinbList[[k - 1]])[, 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1",
                           end.clus = c("m11", "m4"))
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```

## DE analysis

Here is the kind of plots we want to be able to have

```{r}
de <- read.csv('../data/oe_markers.txt', 
              stringsAsFactors = F, header = F)
de <- de$V1
nv <- assays(se)$normalizedValues
plotHeatmap(nv[rownames(nv) %in% de, ],
            main = 'Normalized values, 1000 most variable genes',
            clusterSamplesData = ceObj@dendro_samples,
            sampleData = as.matrix(sampleData$ours))
```

# Session Info

```{r}
sessionInfo()
```
