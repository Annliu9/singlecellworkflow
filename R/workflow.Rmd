---
title: "Worflow"
author: "Workflow team"
date: "06/06/2017"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",message=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
#bioconductor:
library(scRNAseq)
library(scone)
library(clusterExperiment)
#github
library(zinbwave)
library(slingshot)
#CRAN
library(ggplot2)
library(gplots)
library(magrittr)
library(matrixStats)
library(Rtsne)
library(RColorBrewer)
library(digest)
library(rARPACK)
set.seed(20)
if(packageVersion("clusterExperiment")<'1.3.0.9006') stop("must have current develop version to avoid bugs")
```


```{r}
runZinb <- T
runClus <- T
NCORES <- 10
```

EAP: if we are going to ultimately use these functions, it would be good to add them to the package for zinbwave.

FP: yes, I agree.

```{r residuals}
compute.zinb.loglik <- function(Y, zinb){
  mu = t(getMu(zinb)) 
  theta = getTheta(zinb)
  theta_mat = matrix(rep(theta, ncol(Y), ncol = ncol(Y)))
  pi = t(getPi(zinb))
  log( pi * (Y == 0) + (1 - pi) * dnbinom(Y, size = theta, mu = mu) )
}

compute.deviance.residuals <- function(Y, zinb){
  mu_hat = t(getMu(zinb)) 
  pi_hat = t(getPi(zinb)) 
  Y_hat = (1 - pi_hat) * mu_hat
  ll = compute.zinb.loglik(Y, zinb)
  sign = 1*(Y - Y_hat > 0)
  sign[sign == 0] = -1
  sign * sqrt(-2 * ll)
}
```


# TL;DR

This document is a temptative of workflow with the following steps  

- Dimensionality reduction using zinbwave to get W which should capture the biology,
- Cluster cells using clusterExperiment on W to get the cluster labels,   
- Get lineage using slingshot on W and cluster labels from clusterExperiment,  
- Get DE genes between lineages/clusters.  

Along the worflow, use deviance residuals as adjusted values.

EAP: small request. Can everyone put a line between the beginning of a r chunk and text? It makes it nicely formated for my text editor. 

# Steps of the workflow
## Create a SummarizedExperiment object

Along the workflow, we want to use a unique SummarizedExperiement object carrying all the data we need.

EAP: I have updated the code to pull from a dataset on the repos that is created with the `createData.R` file. For now, I am filtering to the top 1000 most variable genes there, though we might want to add that to the code for the article. This will be slightly different data from Russell's, which didn't use all of the samples. We can adjust that decision later, or just compare the samples that are the same. (Russell's clusterLabels are in the meta data)

EAP: zinbFit doesn't accept data.frame objects, so currently have to have a `data.matrix` command. Should it be changed so that it does?

```{r datain}
#counts<-read.table("../data/oeCufflinkCountData.txt",sep="\t",header=TRUE)
core <- read.table("../data/oeCufflinkCountData_1000Var.txt",
                   sep = "\t", header = TRUE)
core <- data.matrix(core)
metadata <- read.table("../data/oeMetadata.txt", sep = "\t", header = TRUE)
# symbol for samples missing from original clustering
metadata$clusterLabels[is.na(metadata$clusterLabels)] <- -2
```

Here we only look at the 1000 most variable genes. EAP: see note above, I've commented out the filtering and added it to the `createData.R` for now. 

```{r batches}
batch <- metadata$Batch
```

Cells have been processed in `r length(unique(batch))` different batches

```{r}
col_batch = rep(brewer.pal(9, "Set1"), 2)
names(col_batch) = unique(batch)
table(batch)
```

We have qc measures from the data

```{r qc}
qc <- metadata[, !names(metadata) %in% c("Batch", "Experiment", "clusterLabels")]
head(qc, 2)
```

```{r clusterlabels}
clus.labels <- metadata[, "clusterLabels"]
```

In published work (FP: add ref), cells have been clustered into `r length(unique(clus.labels))` different clusters

```{r}
col_clus <- c("transparent", brewer.pal(12, "Set3"), brewer.pal(8, "Set2"))
col_clus <- col_clus[1:length(unique(clus.labels))]
names(col_clus) <- sort(unique(clus.labels))
table(clus.labels)
```

Batches are kind of confounded with the biology

```{r}
table(data.frame(batch = as.vector(batch),
                 cluster = clus.labels))
```

We have `r ncol(core)` cells.

```{r lookatdata}
dim(core)
core[1:3, 1:3]
```

Let's create a SummarizedExperiment object to store the raw counts and information about the data, that is batches, published labels, and quality control measures.

```{r}
se <- SummarizedExperiment(assays = list(rawCounts = core),
                           colData = metadata)
```


## Dimensionality reduction adjusting for gene and cell level covariates

To cluster and get lineages we want to reduce the dimension of the data. We are going to use zinbwave to do so. First, let's fit zinbwave with first K = 0 to compute normalized values (i.e. deviance residuals) adjusted for batches. We could also adjust for gene length or GC content here. We then fit zinbwave to get the dimensionality reduced matrix W specifying the number of dimension K = 50. Eventually, we will call zinbwave just once where we would have an argument in zinbFit like "compute_normalized_values" in c(TRUE, FALSE). For K = 0 and K = 50, we correct for batch effect including batches in X.

```{r}
fn0 <- '../data/zinb_k0_batch.rda'
if (runZinb & !file.exists(fn0)){
  mod <- model.matrix( ~ batch)
  print(system.time(zinb0 <- zinbFit(core, ncores = NCORES,
                                     K = 0, X = mod)))
  save(zinb0, file = fn0)
}else{
  load(fn0)
}

fn50 <- '../data/zinb_k50_batch.rda'
if (runZinb & !file.exists(fn50)){
  mod <- model.matrix( ~ batch)
  print(system.time(zinb50 <- zinbFit(core, ncores = NCORES,
                                      K = 50, X = mod)))
  save(zinb50, file = fn50)
}else{
  load(fn50)
}
```

### Normalized values

We use deviance residuals as normalized values for visualization. FP: explain rational: K=0 so residuals capture the bio adjusting for batch. Let's check that deviance residuals look ok.

```{r}
res <- compute.deviance.residuals(core, zinb0)
res[1:3,1:3]
```

Boxplot of the normalized values for each cell. It seems that correction for batches is ok.

```{r}
res_order <- res[, order(as.numeric(batch))]
col_order <- as.numeric(batch)[order(as.numeric(batch))]
boxplot(res_order, main='Boxplot of normalized values\ncolor=batch',
        col = col_order, staplewex = 0, outline = 0, border = col_order, xaxt = 'n')
```

PCA on the normalized values where color are for batches on the left and previously found clusters on the right. We want no clustering on the left side and clustering on the right side.

```{r}
pca <- prcomp(t(res))
par(mfrow = c(1,2))
plot(pca$x, col = col_batch[batch], pch = 20,
     main="PCA of normalized values\ncolor=batch")
plot(pca$x, col = col_clus[as.character(clus.labels)], pch = 20,
     main = "PCA of normalized values\ncolor=cluster")
par(mfrow = c(1,1))
```

Let's add the normalized values as an assay dataset in our SummarizedExperiment object.

```{r}
assays(se)[['normalizedValues']] <- res
```

### W

Let's check that performing MDS on W we have something coherent with published clusters.

```{r}
W <- getW(zinb50)
d <- dist(W)
fit <- cmdscale(d, eig = TRUE, k = 2)
plot(fit$points, col = col_clus[as.character(clus.labels)], main = 'MDS', pch = 20,
     xlab = 'Component 1', ylab = 'Component 2')
legend(x = 'bottomright', legend = unique(names(col_clus)), cex = .5,
       fill = unique(col_clus), title = 'Sample')
```

Let's add W to the colData of our SummarizedExperiment object.

```{r}
W <- data.frame(W)
colnames(W) <- paste0('W', 1:ncol(W))
colData(se) <- cbind(colData(se), W)
```


FP: what do you think of implemented a "compute_normalized_values" argument to zinbFit for summarizedExperiment objects where zinbFit would take as input a SummarizedExperiment object and return a summarizedExperiment object with slots added for normalized values and W?

## Cluster of cells

We use clusterExperiment with W.

EAP: Fanny, we should really be using the RSEC function for all the steps of the clustering. I've put in the code, but I set `eval=FALSE` because I don't have the data to test it. I also am not sure that we want to set the options for `subsampleArgs` and `seqArgs` since those are suppose to be sort of esoteric concerns...

FP: What about the following call to RSEC?

```{r rsec_50}
W <- colData(se)[, grepl('^W', colnames(colData(se)))]
W <- as.matrix(W)
fn <- '../data/RSEC_W.rda'
if (runClus & !file.exists(fn)){
  print(system.time(ceObj <- RSEC(t(W), k0s = 4:15, 
                                  alphas = c(0.3), betas = c(0.9),
                                  clusterFunction = "hierarchical01",
                                  minSizes = 5,
                                  ncores = NCORES,
                                  combineProportion = 0.7,
                                  mergeMethod = "locfdr",
                                  mergeCutoff = 0.01)))
  save(ceObj, file = fn)
}else{
  load(fn)
}
```

```{r examineCombineMany}
plotClusters(ceObj, colPalette = c(bigPalette, rainbow(100)))
```

```{r plotcoclust}
plotCoClustering(ceObj)
```

```{r}
table(primaryClusterNamed(ceObj))
sum(primaryCluster(ceObj) == -1)
```

FP: Elizabeth, we are working with the W here, does the locfdr make sense in this context?

```{r examineMergeClusters}
#re-does merging simpling to make plot 
mergeClusters(ceObj, mergeMethod = "locfdr",
              plotInfo = "mergeMethod", cutoff = 0.05)
```

```{r heatmap }
plotHeatmap(ceObj, clusterSamplesData = "dendrogramValue", 
            breaks = .99)
```

```{r compareClusters}
plot(fit$points, col = col_clus[as.character(clus.labels)],
     main = 'MDS W, color = published clusters', pch = 20,
     xlab = 'Component1', ylab = 'Component2')
```

```{r}
palDF <- ceObj@clusterLegend[[1]]
pal <- palDF[, 'color']
names(pal) <- palDF[, 'name']
plot(fit$points, col = pal[primaryClusterNamed(ceObj)],
     main = 'MDS W, color = our clusters', pch = 20,
     xlab = 'Component1', ylab = 'Component2')
```

```{r}
table(data.frame(published = clus.labels,
                 ours = primaryCluster(ceObj)))
```

So, let's look at a heatmap on normalized values.

```{r}
sampleData <- data.frame(ours = primaryCluster(ceObj))

plotHeatmap(assays(se)$normalizedValues,
            main = 'Normalized values, 1000 most variable genes',
            clusterSamplesData = ceObj@dendro_samples,
            sampleData = as.matrix(sampleData))
```


## Get lineages

The goal of this section is to see if we need to refit zinbwave when we want to run slingshot. We run slingshot in the supervised and unsupervised mode and we try k=2, k=3, k=4 in W.

FP: We need to work on the cluster coloring (!) and the matching with the clusters you found for the paper with Russell, maybe by changing the parameters in clusterMany?

```{r}
Kvec <- c(2, 3, 4)
```

### Use previous W, no re-fitting 
#### Unsupervised

```{r slingshot_unsup}
our_cl <- as.factor(primaryClusterNamed(ceObj))
cl = our_cl[our_cl != "-1"]
for (k in Kvec){
  X <- W[our_cl != "-1", 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1")
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```

#### Supervised

```{r slingshot_sup}
for (k in Kvec){
  X <- W[our_cl != "-1", 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1",
                           end.clus = c("m8", "m4"))
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```


### Re-fitting zinbwave
#### Unsupervised

```{r refit_zinb}
mod <- model.matrix(~ batch[our_cl != "-1"])
fn <- '../data/refit_zinbwave_slingshot.rda'
if (runZinb & !file.exists(fn)){
  zinbList <- lapply(Kvec, function(k){
    zinbFit(core[, our_cl != "-1"], X = mod, K = k, ncores = NCORES)
  })
  save(zinbList, file = fn)
}else{
  load(fn)
}
```

```{r slingshot_unsup_refit}
for(k in Kvec) {
  X <- getW(zinbList[[k - 1]])[, 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1")
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```

#### Supervised

```{r slingshot_sup_refit}
for(k in Kvec){
  X <- getW(zinbList[[k - 1]])[, 1:k]

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1",
                           end.clus = c("m8", "m4"))
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal)
  plot_tree(X, cl, lineages, col.clus = pal)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
}
```

## DE analysis

Here is the kind of plots we want to be able to have

```{r}
de <- read.csv('../data/oe_markers.txt', 
              stringsAsFactors = F, header = F)
de <- de$V1
nv <- assays(se)$normalizedValues
plotHeatmap(nv[rownames(nv) %in% de, ],
            main = 'Normalized values, 1000 most variable genes',
            clusterSamplesData = ceObj@dendro_samples,
            sampleData = as.matrix(sampleData$ours))
```

# Session Info

```{r}
sessionInfo()
```
