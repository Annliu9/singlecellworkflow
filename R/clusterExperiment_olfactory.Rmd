---
title: "clusterExperiment on olfactory data"
author: "Fanny Perraudeau"
date: "05/10/2017"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: show
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(SummarizedExperiment)
library(clusterExperiment)
library(limma)
set.seed(20)
```


## TL;DR

The goal of this document is to create a worflow to cluster scRNASeq data with an example on olfactory data. It is not meant to be the final document where we would expect more written explanations. It is meant to choose the functions, parameters, and plots we want to show. Another goal of this document is also to see how we could use clusterExperiment in combinaison with zinbwave.

```{r dataIn}
load('../data/Expt4c2b_filtdata.Rda')
load('../data/E4c2b_slingshot_wsforkelly.RData')
load('olfactory.rda')
```

Let's create a SummarizedExperiment object. In colData, we add a column for the batches and another column for the clus.labels.

**Could you remind me where are the clus.labels from? I think we should have a more explicit name, like bio_condition or paper_clusters.**

```{r}
names(batch) <- colnames(counts)
counts <- counts[,names(clus.labels)]
batch <- droplevels(batch[names(clus.labels)])
qc <- qc[names(clus.labels),]
qc$batch = batch
qc$clusters = clus.labels

se = SummarizedExperiment(assays = list(counts = counts),
                          colData = qc)

assay(se)[1:2,1:5]
colData(se)[,1:5]
```

Let's filter out genes with too many zeros and normalize counts using FQ limma normalization.
```{r}
pass_filter = apply(assay(se), 1, function(x) length(x[x >= 10]) >= 10)
se <- se[pass_filter,]
dim(se)
fq <- round(limma::normalizeQuantiles(assay(se)))
assays(se) <- list(normalized_counts=fq)
```


## clusterMany

We included the clus.labels and batch. It is wanted that the cells don't cluster by batch. 

**I think this is where we could include zinbwave. We could add zinbwave as dimReduce in clusterExperiment with an argument similar to nPCADims (something like nZINBDims) which would correspond to the K in the W matrix. We could then skip the normalization of the counts using limma (see above). We would need to set isCount = FALSE. Thoughts?**

```{r}
ce <- clusterMany(se,
                  clusterFunction = "pam",
                  ks = seq(9, 15, 3),
                  isCount = TRUE,
                  dimReduce = c("PCA", "var"),
                  nVarDims = c(100, 500, 1000),
                  nPCADims = c(5, 15, 50),
                  run = TRUE)

defaultMar <- par("mar")
plotCMar <- c(1.1, 16.1, 4.1, 1.1)
par(mar = plotCMar)
plotClusters(ce,
             main = "Clusters from clusterMany",
             axisLine = -1,
             sampleData=c("batch","clusters"))
```

Remove 'features' from the clusters labels to have more succint names.
```{r}
cl = clusterLabels(ce)
cl = gsub("Features", "", cl)
clusterLabels(ce) = cl
```

Re-order the clusters by dimension and not by k.
```{r}
cl = clusterLabels(ce)
ndims = sapply(cl, function(x) strsplit(x, '=|,')[[1]][2])
ord <- order(as.numeric(ndims))
par(mar = plotCMar)
plotClusters(ce,
             main = "Clusters from clusterMany",
             whichClusters = ord, axisLine = -1,
             sampleData=c("batch","clusters"))
```

The output matrix of clusterMany is
```{r}
clusterMatrix(ce)[1:3,1:3]
```

## CombineMany
```{r}
ce = combineMany(ce)
head(clusterMatrix(ce)[,1:3])
```

Look at the new row added for combineMany
```{r}
par(mar = plotCMar)
plotClusters(ce, whichClusters = "workflow",
             axisLine = -1, main = "Clusters from clusterMany",
             sampleData=c("batch","clusters"))
```

clusterMany requires samples to be in the same cluster in every clustering to be assigned a cluster. We need to change the minimum proportion of times they should be together with other samples in the cluster they are assigned to.
```{r}
wh = which(clusterLabels(ce) == "combineMany")
if (length(wh) != 1){
  stop()
}else{
  clusterLabels(ce)[wh] = "combineMany,default"
} 
# change proportion
ce = combineMany(ce, proportion = 0.7,
                 clusterLabel = "combineMany,0.7")
# plot
par(mar=plotCMar)
plotClusters(ce, whichClusters = "workflow",
             axisLine = -1, main = "Clusters from clusterMany",
             sampleData=c("batch","clusters"))
```
We can also play with the minSize parameter.
```{r}
# change minsize
ce = combineMany(ce, proportion = 0.7, minSize = 5, 
                 clusterLabel = "combineMany,final")
# plot
par(mar=plotCMar)
plotClusters(ce, whichClusters = "workflow",
             axisLine = -1, main = "Clusters from clusterMany",
             sampleData=c("batch","clusters"))
```


The proportion of times these clusters were together across these clusterings
```{r}
plotCoClustering(ce)
```

## mergeClusters
Cluster hierarchy for combineMany,final where before clustering PCA is performed and 15 most variable genes are kept 
```{r}
# makeDendrogram
ce = makeDendrogram(ce, whichCluster = "primaryCluster",
                    dimReduce = "PCA", ndims = 15)
plotDendrogram(ce)
```

We have not merged the clusters yet, but we have made the dendrogram
```{r}
ce
```

Before to actually merge the clusters, we are going to visualize the merge at the default cutoff (0.1)
```{r}
mergeClusters(ce, mergeMethod = "adjP", plot = "mergeMethod")
```

```{r}
ce = mergeClusters(ce, mergeMethod = "adjP", cutoff = 0.1)
```

```{r}
par(mar = plotCMar)
plotClusters(ce, whichClusters = "workflow", 
             axisLine = -1, main = "Clusters from clusterMany",
             sampleData=c("batch","clusters"))
```

```{r}
plotCoClustering(ce, sampleData = c("clusters"),
                 whichClusters = c("mergeClusters", 
                                   "combineMany"),
                 annLegend = FALSE)
```

```{r}
plotHeatmap(ce, clusterSamplesData = "dendrogramValue",
            breaks = .99,
            sampleData = c("clusters"))
```

## getBestFeatures
DE genes between clusters using limma voom
```{r}
pairsAll = getBestFeatures(ce, contrastType = "Pairs", 
                           p.value = 0.05,
                           number = 10,
                           isCount = TRUE)
head(pairsAll)
length(pairsAll$Feature) == length(unique(pairsAll$Feature))
```

```{r}
main = "Heatmap of features w/ significant pairwise differences"
clusterFeaturesData = unique(pairsAll[,"IndexInOriginal"])
plotHeatmap(ce, clusterSamplesData = "dendrogramValue",
            clusterFeaturesData = clusterFeaturesData,
            main = main, breaks = .99)
```

