---
title: "Consensus clustering after ZINB-WAVE across different k"
author: "Davide Risso"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, error=FALSE, message=FALSE, warning=FALSE)

library(zinbwave)
library(clusterExperiment)

run_zinb <- FALSE
run_cluster <- FALSE
```

This workflow should help us decide if it's meaningful to run ZINB-WAVE with 
different values of k to get a consensus clustering or if it's better to pick "the right k."

## INPUT DATA

For now I'm using the data that I have stored in my computer, but eventually we
should start with the data from GEO. Question: which one? RSEM? Cufflinks? Kallisto?

```{r datain}
load("~/git/scone_analysis/data/olfactory_for_scone.rda")
se <- as(scone_obj, "SummarizedExperiment")
colData(se)

labels <- read.table("https://raw.githubusercontent.com/rufletch/p63-HBC-diff/master/ref/oeHBCdiff_clusterLabels.txt", row.names = 1)
cl <- labels[,1]
names(cl) <- rownames(labels)
table(cl)

original <- rep(-1, NCOL(se))
names(original) <- colnames(se)
original[intersect(names(cl), colnames(se))] <- cl[intersect(names(cl), colnames(se))]

palette <- read.table("https://raw.githubusercontent.com/rufletch/p63-HBC-diff/master/ref/oeHBCdiff_colorPalette.txt", comment.char = "%", stringsAsFactors = FALSE)
pal <- c("transparent", palette[,2])
names(pal) <- c("-1", palette[,1])

colData(se)$original_cluster <- as.factor(original)
```

# ZINB-WaVE

First of all, we check that with K=2 we get something reasonable.

For now, let's focus on the 1000 most variable genes, but eventually one question
is which genes to use and how to decide.

```{r vargenes}
vars <- rowVars(log1p(assay(se)))
names(vars) <- rownames(se)
vars <- sort(vars, decreasing = TRUE)
core <- se[names(vars)[1:1000],]
core
```


```{r zinb}
zinb2 <- zinbFit(core, X = "~batch", K = 2, ncores = 7)
plot(getW(zinb2), pch=19, col=pal[colData(core)$original_cluster])
```

This seems fine.

Since we are running clusterExperiment on the first 50 principal components,
what happens if we run zinb with k=50?

```{r zinb_50}
zinb50 <- zinbFit(core, X = "~batch", K = 50, ncores = 7)
plot(getW(zinb50), pch=19, col=pal[colData(core)$original_cluster])
```

## Run for multiple k

```{r zinb_k}
ks <- 3:10

if(run_zinb) {
  zinb_res <- lapply(ks, function(k) zinbFit(core, X = "~batch", K = k, ncores=7))
  save(zinb_res, file="../data/zinb_k3_10.rda")
} else {
  load("../data/zinb_k3_10.rda")
}
```

```{r zinb_plot, eval=FALSE}
for(i in seq_along(ks)) {
  pairs(getW(zinb_res[[i]]), pch=19, col=pal[colData(core)$original_cluster])
}
```

# ClusterExperiment

```{r clustering}
ws <- lapply(zinb_res, function(x) t(getW(x)))
if(run_cluster) {
  cl_res <- clusterMany(ws, ks = 5:15, alphas = c(0.1, 0.3), betas = 0.9,
                        clusterFunction = "hierarchical01", minSizes=5,
                        sequential = TRUE, subsample = TRUE, ncores = 7)
  save(cl_res, file="../data/cl_k3_10.rda")
} else {
  load("../data/cl_k3_10.rda")
}
```

## Consensus across all k

```{r consensus}
combined <- combineMany(cl_res$clMat, proportion = 0.5)
dendro <- makeDendrogram(ws[[8]], combined$clustering)
merged <- mergeClusters(assay(core), combined$clustering, dendro$clusters, mergeMethod = "adjP")

clmat <- cbind(merged$clustering, combined$clustering, cl_res$clMat)

plotClusters(clmat)
```

## Consensus using only one k

### k=15

```{r consensus_k}
combined <- combineMany(cl_res$clMat[,grep("dataset8", colnames(cl_res$clMat))],
                        proportion = 0.5)
dendro <- makeDendrogram(ws[[8]], combined$clustering)
merged <- mergeClusters(assay(core), combined$clustering, dendro$clusters, mergeMethod = "adjP")

clmat <- cbind(merged$clustering, combined$clustering, cl_res$clMat)

plotClusters(clmat)
```

### k=50

```{r consensus_50}
## matching the parameters used by Russell
W <- t(getW(zinb50))

if(run_cluster) {
  cl_res <- clusterMany(W, ks = 4:15, alphas = c(0.1), betas = 0.8,
                        clusterFunction = "hierarchical01", minSizes=1,
                        sequential = TRUE, subsample = TRUE, ncores = 7,
                        subsampleArgs = list(resamp.num=100,
                                             clusterFunction="kmeans",
                                             clusterArgs=list(nstart=10)),
                        seqArgs = list(k.min=3, top.can=5), verbose=TRUE)
  save(cl_res, file="../data/cl_k50.rda")
} else {
  load("../data/cl_k50.rda")
}

```

```{r combine_50}
combined <- combineMany(cl_res, proportion = 0.7)

plotClusters(combined, colPalette = c(bigPalette, rainbow(100)))

table(primaryClusterNamed(combined))
sum(primaryCluster(combined) == -1)
sum(colData(core)$original_cluster == -1)

table(primaryClusterNamed(combined), colData(core)$original_cluster)

plot(getW(zinb50), pch=19, col=pal[colData(core)$original_cluster])
plot(getW(zinb50), pch=19, col=pal[as.factor(primaryCluster(combined))])

combined <- makeDendrogram(combined)
plotDendrogram(combined)
merged <- mergeClusters(combined, mergeMethod = "locfdr", cutoff = 0.01)

# 
# plot(getW(zinb50), pch=19, col=pal[as.factor(primaryCluster(merged))])

plotCoClustering(combined)
```

# Slingshot

Let's try to run slingshot on W, with different values of k to see how stable the
lineages are. We run slingshot in two modes, one in which we specify only the starting
cluster (unsupervised) and one in which we specify the end clusters too (supervised).

A note on the interpretation of the clusters.

Cluster name | Description | Correspondence
-------------|-------------|-----------------
c1 | resting HBC | original 1, 5
c2 | activated HBC | original 5
c3 | GBC / immature neurons / MV 1 | original 2, 3, 11
c4 | Sus | original 4, 7
c5 | new | new
c6 | new | new
c7 | Neuron | original 9, 12
c8 | Immature Neuron | original 10, 14
c9 | Microvillus | original 15
c10 | Immature Neuron | original 14

Cluster name | Correspondence | Description
-------------|-----------------|-------------
m1 | c1 + c2 | HBC
m2 | c3 + c10 | GBC + immature nerons
m3 | c4 | Sus
m4 | c5 + c6 | new
m5 | c7 | Neuron
m6 | c8 | Immature Neuron
m7 | c9 | Microvillus

## Unsupervised

We try with k=3, k=4, k=5.

```{r slingshot}
library(slingshot)
pal2 <- pal[-1][c(1, 5, 3, 4, 2, 10, 11, 9, 13)]
pal3 <- pal[-1][c(1, 3, 4, 2, 11, 9, 13)]
cl_labs <- as.factor(primaryClusterNamed(merged))
cl <- droplevels(cl_labs[cl_labs != "-1"])

for(k in c(3, 4, 5)) {
  zinb_k <- zinbFit(core[,cl_labs != "-1"], X = "~batch", K = k, ncores = 7)
  X <- getW(zinb_k)

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1")
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal3)
  plot_tree(X, cl, lineages, col.clus = pal3)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
  print(lineages$lineage5)
}
```

## Supervised

We try with k=3, k=4, k=5.

```{r slingshot_sup}
for(k in c(3, 4, 5)) {
  zinb_k <- zinbFit(core[,cl_labs != "-1"], X = "~batch", K = k, ncores = 7)
  X <- getW(zinb_k)

  lineages <- get_lineages(X, clus.labels = cl, start.clus = "m1", end.clus = c("m3", "m5", "m7"))
  curves <- get_curves(X, clus.labels = cl, lineages = lineages)
  plot_curves(X, cl, curves, col.clus = pal3)
  plot_tree(X, cl, lineages, col.clus = pal3)

  print(paste0("K=", k))
  print(lineages$lineage1)
  print(lineages$lineage2)
  print(lineages$lineage3)
  print(lineages$lineage4)
  print(lineages$lineage5)
}
```

# Session Info

```{r}
sessionInfo()
```
