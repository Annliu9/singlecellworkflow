---
title: "Analysis of the olfactory data"
author: "Davide Risso, Fanny Perraudeau"
date: "05/04/2017"
output: 
  html_document: 
    fig_height: 7
    fig_width: 7
    toc: yes
    code_folding: hide
    toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(SummarizedExperiment)
library(scRNAseq)
library(zinbwave)
library(ggplot2)
library(magrittr)
library(matrixStats)
library(Rtsne)
library(scone)
library(RColorBrewer)
library(digest)
library(scone)
library(rARPACK)
set.seed(20)
```


## TL;DR

Applying our zero-inflated model to the olfactory data.

## Unnormalized data

We select only the cells that pass QC, color coded by the experimental time point. Note that the data are not public, hence it should not work other than on Davide's computer.  

**I think Kelly said the data are now publicly available. How do we get the publicly available dataset?**


```{r datain}
load("../data/Expt4c2b_filtdata.Rda")
load("../data/E4c2b_slingshot_wsforkelly.RData")
```


```{r filtering}
names(batch) <- colnames(counts)

counts <- counts[,names(clus.labels)]
batch <- droplevels(batch[names(clus.labels)])
qc <- qc[names(clus.labels),]

vars <- rowVars(log1p(counts))
names(vars) <- rownames(counts)
vars <- sort(vars, decreasing = TRUE)
core <- counts[names(vars)[1:1000],]
```


We have `r ncol(counts)` cells. To speed up the computations, we will focus on the top 1,000 most variable genes.
```{r lookatdata}
dim(core)
core[1:3, 1:3]
```

Cells have been processed in `r length(unique(batch))` different batches
```{r tabbatch}
table(batch)
```

Cells have been clustered into `r length(unique(clus.labels))` different clusters
```{r tabclus}
table(clus.labels)
```

Batches are kind of confounded with the biology
```{r}
table(data.frame(batch = as.vector(batch),
                 cluster = clus.labels))

```

**Could you remind me where the clusters come from?**


For each cell, we dispose of qc measures
```{r}
head(qc, 2)
```

## PCA

First, let's look at PCA (of the log counts) for reference.

```{r pca}
par(mfrow=c(1, 2))
detection_rate <- colSums(core>0)
coverage <- colSums(core)
colMerged <- cc_rev[clus.labels]

pca <- prcomp(t(log1p(core)))
plot(pca$x, col=colMerged, pch=19, main="PCA of log-counts, centered not scaled")

fq <- EDASeq::betweenLaneNormalization(counts, which="full")
pcafq <- prcomp(t(log1p(fq)))
plot(pcafq$x, col=colMerged, pch=19, main="PCA of FQ log-counts, centered not scaled")
```

The first plot is the unnormalized data and the second plot is after full-quantile normalization, which is what Russell and Diya used for the paper.

**Do we have a reference for this paper?**  

**Is it a fair comparison?? for pca on log counts, we use the 1000 most variable genes, but for full quantile normalization, we use all the genes. I understand that to perform full quantile normalization we need all the genes, but then should we look at only the 1000 most variable genes defined above, no?**

They found that to fully explain the differences between clusters, we need three dimensions.

```{r pca3}
pairs(pcafq$x[,1:3], col=colMerged, pch=19,
      main="PCA of FQ log-counts, centered not scaled")
```

```{r pca_cor}
df <- data.frame(PC1 = pcafq$x[, 1],
                 PC2 = pcafq$x[, 2],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch = 19, col = colMerged)

print(cor(df, method = "spearman"))
```

Even after full-quantile normalization, there is some residual correlation between PC2 and detection rate. Note that, as expected, detection rate and coverage are correlated.

```{r pca_tosave}
totalcount = function (ei) {
  sums = colSums(ei)
  eo = t(t(ei)*mean(sums)/sums)
  return(eo)
}
raw <- as.matrix(counts)
tc <- totalcount(raw)
fq <- FQT_FN(raw)
tmm <- TMM_FN(raw)

fastpca <- function(expr, scale=FALSE) {
  svd_raw <- svds(scale(t(expr), center=TRUE, scale=scale), k=3, nu=3, nv=0)
  pc_raw <- svd_raw$u %*% diag(svd_raw$d[1:3])
  return(pc_raw)
}
vargenes <- rownames(core)
pc_raw <- fastpca(log1p(raw[vargenes,]))
pc_tc <- fastpca(log1p(tc[vargenes,]))
pc_fq <- fastpca(log1p(fq[vargenes,]))
pc_tmm <- fastpca(log1p(tmm[vargenes,]))
```

## ZIFA

Let's now look at zifa.

```{r zifa}
wrapRzifa <- function(Y, block = TRUE, k=2){
  # wrapper R function for ZIFA.
  # md5 hashing and temporary files are used not to re-run zifa 
  # if it has already be run on this computer.
  d = digest(Y, "md5")
  tmp = paste0(tempdir(), '/', d)
  write.csv(Y, paste0(tmp, '.csv'))
  
  if (!file.exists(paste0(tmp, "_", k, '_zifa.csv'))){
    print('run ZIFA')
    bb = ifelse(block, '-b ', '')
    cmd = sprintf('python run_zifa.py -d %d %s%s.csv %s_%d_zifa.csv', k, bb, tmp, tmp, k)
    system(cmd)
  }
  read.csv(sprintf("%s_%d_zifa.csv", tmp, k), header=FALSE)
}

zifa_raw <- wrapRzifa(log1p(raw[vargenes,]), k=3)

zifa_tc <- wrapRzifa(log1p(tc[vargenes,]), k=3)

zifa_tmm <- wrapRzifa(log1p(tmm[vargenes,]), k=3)

zifa_fq <- wrapRzifa(log1p(fq[vargenes,]), k=3)
```

```{r zifaplots}
pairs(zifa_raw[,1:3], col=colMerged, pch=19,
      main="ZIFA of raw log-counts")

pairs(zifa_fq[,1:3], col=colMerged, pch=19,
      main="ZIFA of FQ log-counts")

```

## ZINB

### Three dimensions
```{r zinb}
print(system.time(zinb_3 <- zinbFit(core, ncores = 3, K = 3)))
```

```{r zinb_plot}
pairs(zinb_3@W, col = colMerged, pch = 19, main = "ZINB")
```

```{r gamma}
qcpca <- prcomp(qc, center = TRUE, scale. = TRUE)
df <- data.frame(W1 = zinb_3@W[,1],
                 W2 = zinb_3@W[,2], 
                 W3 = zinb_3@W[,3],
                 gamma_mu = zinb_3@gamma_mu[1,],
                 gamma_pi = zinb_3@gamma_pi[1,],
                 detection_rate=detection_rate,
                 coverage = coverage, 
                 quality = qcpca$x[,1])
pairs(df, pch = 19, col = colMerged)

print(cor(df, method = "spearman"))
```

### Five dimensions

```{r}
print(system.time(zinb_5 <- zinbFit(core, ncores = 3, K = 5)))
```

```{r}
pairs(zinb_5@W, col = colMerged, pch = 19, main = "ZINB")
```

### Ten dimensions

```{r}
print(system.time(zinb_10 <- zinbFit(core, ncores = 3, K = 10)))
```

```{r}
pairs(zinb_10@W, col = colMerged, pch = 19, main = "ZINB")
```


### Accounting for quality

```{r qpca}
mod <- model.matrix(~ qcpca$x[, 1:5])
```

```{r}
print(system.time(zinb_3_qc <- zinbFit(core, ncores = 3, K = 3, X = mod)))
```

```{r}
pairs(zinb_3_qc@W, col=colMerged, pch=19, main="ZINB")
```

```{r}
#total number of detected genes in the cell
df <- data.frame(W1 = zinb_3_qc@W[,1],
                 W2 = zinb_3_qc@W[,2],
                 W3 = zinb_3_qc@W[,3],
                 gamma_mu = zinb_3_qc@gamma_mu[1,],
                 gamma_pi = zinb_3_qc@gamma_pi[1,],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch = 19, col = colMerged)

print(cor(df, method = "spearman"))
```

K = 5
```{r}
print(system.time(zinb_5_qc <- zinbFit(core, ncores = 3, K = 5, X = mod)))
```

```{r}
pairs(zinb_5_qc@W, col=colMerged, pch=19, main="ZINB")
```


K = 10
```{r}
print(system.time(zinb_10_qc <- zinbFit(core, ncores = 3, K = 10, X = mod)))
```

```{r}
pairs(zinb_10_qc@W, col=colMerged, pch=19, main="ZINB")
```

### Accounting for batch

```{r}
class(batch)
mod <- model.matrix(~ batch)
dim(mod)
```

```{r}
print(system.time(zinb_3_batch <- zinbFit(core, ncores = 3, K = 3, X = mod)))
```

```{r}
pairs(zinb_3_batch@W, col=colMerged, pch=19, main="ZINB")
```

```{r}
#total number of detected genes in the cell
df <- data.frame(W1 = zinb_3@W[,1],
                 W2 = zinb_3@W[,2],
                 W3 = zinb_3@W[,3],
                 gamma_mu = zinb_3@gamma_mu[1,],
                 gamma_pi = zinb_3@gamma_pi[1,],
                 detection_rate = detection_rate,
                 coverage = coverage)
pairs(df, pch = 19, col = colMerged)

print(cor(df, method = "spearman"))
```

K = 5
```{r}
print(system.time(zinb_5_batch <- zinbFit(core, ncores = 3, K = 5, X = mod)))
```

```{r}
pairs(zinb_5_batch@W, col=colMerged, pch=19, main="ZINB")
```


K = 10
```{r}
print(system.time(zinb_10_batch <- zinbFit(core, ncores = 3, K = 10, X = mod)))
```

```{r}
pairs(zinb_10_batch@W, col=colMerged, pch=19, main="ZINB")
```



### Accounting for batch and quality

```{r}
mod <- model.matrix(~ qcpca$x[, 1:5] + batch)
```

```{r}
print(system.time(zinb_3_qc_batch <- zinbFit(core, ncores = 3, K = 3, X = mod)))
```

```{r}
pairs(zinb_3_qc_batch@W, col=colMerged, pch=19, main="ZINB")
```


K = 5
```{r}
print(system.time(zinb_5_qc_batch <- zinbFit(core, ncores = 3, K = 5, X = mod)))
```

```{r}
pairs(zinb_5_qc_batch@W, col=colMerged, pch=19, main="ZINB")
```

K = 10
```{r}
print(system.time(zinb_10_qc_batch <- zinbFit(core, ncores = 3, K = 10, X = mod)))
```

```{r}
pairs(zinb_10_qc_batch@W, col=colMerged, pch=19, main="ZINB")
```



```{r save, dependson="zifa"}
save(zinb_3, zinb_5, zinb_10,
     zinb_3_qc, zinb_5_qc, zinb_10_qc, 
     zinb_3_batch, zinb_5_batch, zinb_10_batch,
     zinb_3_qc_batch, zinb_5_qc_batch, zinb_10_qc_batch,
     pc_tmm, pc_fq, pc_tc, pc_raw,
     zifa_fq, zifa_tmm, zifa_tc, zifa_raw,
     file="olfactory.rda")
```
